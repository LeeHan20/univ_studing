시스템프로그래밍기초 4주차

연산자
- 기호로 된 명령

    연산자     |              의미               |   결합 순서        
-------------|--------------------------------|-----------------
()           | 괄호(묶음)                       | 왼쪽에서 오른쪽  
[]           | 배열 인덱스                       |                 
.            | 멤버 선택                        |                 
->           | 포인터에 의한 멤버 선택             |                 
++ --        | 후위 증감                        |                 
++ --        | 전위 증감                        | 왼쪽에서 오른쪽  
+ -          | 단항 연산(부호)                   |                 
! ~          | 논리 NOT, 비트 단위 NOT           |                 
(type)       | 형 변환                          |                 
sizeof       | 데이터 크기                      |                 
&            | 주소 연산자                      |                 
*            | 참조 연산자                      |                 
* / %        | 2항 연산(곱셈, 나눗셈, 나머지)       | 왼쪽에서 오른쪽  
+ -          | 2항 연산(덧셈, 뺄셈)              |                 
<< >>        | 비트 단위 왼쪽 시프트, 오른쪽 시프트   |                 
> >= < <=    | 관계 연산(크기 비교)               |                 
== !=        | 관계 연산(Equal, Not Equal)      |                 
&            | 비트 단위 AND                    |                 
^            | 비트 단위 XOR                    |                 
|            | 비트 단위 OR                     |                 
&&           | 논리 AND                        |                 
||           | 논리 OR                         |                 
=            | 대입(할당)                       | 오른쪽에서 왼쪽 
+= -=        | 복합 대입 연산자(덧셈, 뺄셈)         |                 
*= /=        | 복합 대입 연산자(곱셈, 나눗셈)        |                 

증감 연산자의 전위형과 후위형
- 전위형 : 변수가 사용되기(참조되기) 전에  증가 or 감소
- 후위형 : 변수가 사용된(참조된) 후에 증가 or 감소

논리연산자 (at. c)
- 0이 아니면 모두 true
- true는 보통 1을 쓰긴 함

비트 연산자
- 데이터의 각각의 bit값을 제어할 때 쓰임
- bit & -> 특정 비트를 0으로 만들 때 씀 (bit clear를 할 때)
- bit | -> 특정 비트를 1로 만들 때 씀 (bit set을 할 때)
- bit ^ -> 특정 비트를 반전시킬 때 씀 (선택적 반전)
- bit ~ -> 특정 비트를 반전시킬 때 씀 (전체 반전)
- bit 

ex.1)
  0101 0011 (83) ---> clear가 필요한 부분
& 0000 1111 (15) ---> clear에 필요한 0, 그대로 둘 부분 1
  ---------------
  0000 0011 (clear)

ex.2)
  0101 0010 (82) ---> set이 필요한 부분
| 1111 0000 (240) ---> set이 필요한 부분 1, 그대로 둘 부분 0
  ----
  1111 0010 (set)

ex.3)
  0110 0010 (98) ---> 반전이 필요한 부분
^ 1111 0000 (240) ---> 반전이 필요한 부분 1, 그대로 둘 부분 0
  ----
  1001 0010 (반전)

cf. 아래에 있는 바꾸는데 필요한 비트를 제공하는 부분을 마스크라고 부름
cf. 나머지 연산을 할 때 사용될 수 있음

bit shift
- 왼쪽으로 옮김 (<<) -> 10진법 기준 *(2^옮긴 칸 수)
- 오른쪽으로 옮김 (>>) -> 10진법 기준 *(1/2^옮긴 칸 수)

함수
- 말로 된 명령 (소괄호)

//시스템프로그래밍 4주차
#include <stdio.h>
#include <limits.h>

int main(void) {
//    ----------------------- 3-12 -------------------------
    unsigned int a = 25;
    unsigned int left, right;
    
    left = a << 3;
    //a*2^3
    printf("%d \n", left);
    
    right = a >> 2;
    //a*2^2
    printf("%d \n", right);
    
//    ----------------------- 3-11 -------------------------
    int a = 105, b = 32;
    
    printf("%d \n", a % 32);
    printf("%d \n", a & 0x1f);
    
//    ----------------------- 3-10 -------------------------
    int a = 105; //0x69 -> 0110 1001
    int b = 85; //0x55 -> 0101 0101
    
    printf("%x \n", a & b);
    printf("%x \n", a | b);
    printf("%x \n", a ^ b);
    
    printf("%d \n", ~a + 1);
    
//    ----------------------- 3-9 -------------------------
    int a = 4, b = 3, c = 2, d = 1;
    
    printf("%d \n", (a > b) && (c > d));
    
    printf("%d \n", (a < b) && (d = 100));
    //and 연산자에서 앞의 값이 0이라면 뒤의 연산은 실행하지 않음
    //and에서는 dominant value가 0이기 때문임
    printf("d = %d \n", d);
    //-> d = 1이 나옴
    
    printf("%d \n", (a > b) || (d = 200));
    //여기서도 똑같이 or에서 앞이 1이라면 뒤의 연산은 실행하지 않음
    //or에서는 dominant value가 1이기 때문
    printf("d = %d \n", d);
    //-> d = 1이 나옴
    
    printf("%d \n", !(a > b));
    
//    ----------------------- 3-8 -------------------------
    int a = 10, b = 5;
    double p = 10.0;
    double q = 5.02;
    double r = 10.00000000000000001;
    
    printf("%d \n", a > b);
    printf("%d \n", a >= b);
    printf("%d \n", a == b);
    printf("%d \n", a != b);
    
    printf("%d \n", p > q);
    printf("%d \n", p == r);
    //유효숫자를 초과하여 컴퓨터가 멍청해짐
    //실수에 대해서는 비교연산자 사용을 주의할 것
    
//    ----------------------- 3-7 -------------------------
    int a, b;
    
    a = 0;
    
    a++;
    //++a;
    
    printf("a is %d \n", a);
    
    b = a++;
    //여기서 a에 후위연산자가 사용되었기 때문에
    //b에 a의 값이 할당된 후에 a가 1 증가함
    //a에 1을 더한 후 b에 할당하고 싶다면 ++a를 사용하면 됨
    
    printf("a is %d, b is %d \n", a, b);
    
    a = 0;
    a++;
    printf("a is %d \n", a);
    
    a = b = 0;
    
    printf("value is %d, b is %d \n", (1 + a++) + 2, ++b);
    //a와 1이 더해진 후 a가 1 증가하고 2가 더해짐
    //식은 3을 리턴하고 a는 1이 됨
    
    printf("a is %d, b is %d \n", a, b);
    
//    ----------------------- 3-6 -------------------------
    int a, b;
    
    a = 8;
    
    a += 2;
    
    printf("a is %d \n", a);
    
    b = 2;
    a /= b;
    
    printf("a is %d \nb is %d \n", a, b);
    
//    ----------------------- 3-5 -------------------------
    short a = 32768;
    //0x00 00 80 00인 16진수로 컴파일이 될 것임
    //경고 메시지 : Implicit conversion from 'int' to 'short' changes value from 32768 to -32768
    
    short b = a / 2;
    //a는 2바이트인데 2는 4바이트라서 a를 확장해서 계산함
    
    float c = 1E45;
    float d = c / 2.0;
    
    printf("a : %d, b ; %d c : %f, d : %f \n", a, b, c, d);
    //여기서 %d는 signed int로 출력하라는 명령인데
    //a는 2바이트라서 확장을 할 필요가 있음

//    ----------------------- 3-4 -------------------------
    int a = 10, b = 3;
    double p = 10.0, q = 3.0;
    
    printf("10 + 3 = %d \n", a + b);
    printf("10 - 3 = %d \n", a - b);
    printf("10 * 3 = %d \n", a * b);
    printf("10 / 3 = %d \n", a / b);
    printf("10 %% 3 = %d \n", a % b);
    
    
    printf("10.0 + 3.0 = %f \n", p + q);
    printf("10.0 - 3.0 = %f \n", p - q);
    printf("10.0 * 3.0 = %f \n", p * q);
    printf("10.0 / 3.0 = %f \n", p / q);
    
//    ----------------------- 3-1 -------------------------
    int salary, bouns, total;
    
    salary = 400;
    bouns = 20;
    
    total = salary + bouns;
    
    printf("total is %d \n", total);
    
    bouns = salary = 400;
    
    printf("bouns + salary is %d \n", bouns + salary);
    
    printf("%d \n", bouns = 500);
    
//    ----------------------- 3-1 -------------------------
    int my_age, your_age;
    //변수 생성
    //여기에는 쓰레기값(garbage value)이 들어있는데 컴퓨터의 해당 주소에
    //원래 할당되어 있던 값이 그냥 들어감
    
    int her_age = 20;
    //선언과 값 대입 동시에 -> 초기화
    
    my_age = her_age + 1;
    
    printf("my_age is %d \n", my_age);
    
    your_age = her_age + 1;
    my_age = your_age + 1;
    
    printf("my_age is %d \n", my_age);
    
    return 0;
}

